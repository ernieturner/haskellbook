
==================== FINAL INTERFACE ====================
2017-02-01 05:07:22.787635 UTC

interface main@main:Puzzle 8001
  interface hash: 772f8d84d233bd6feb205b3640c49b05
  ABI hash: dc423cbdb6629acc810c67f4d4ad9142
  export-list hash: d6ae66569fb97d316eb681a8a12e4320
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: db42a6ce2dcb446cbc4bd8f7ba6d311a
  sig of: Nothing
  used TH splices: False
  where
exports:
  Puzzle.alreadyGuessed
  Puzzle.charInWord
  Puzzle.fillInCharacter
  Puzzle.freshPuzzle
  Puzzle.gameOver
  Puzzle.gameWin
  Puzzle.handleGuess
  Puzzle.renderPuzzleChar
  Puzzle.runGame
  Puzzle.Puzzle{Puzzle.Puzzle}
module dependencies:
package dependencies: base-4.9.0.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.0.0:GHC.Base base-4.9.0.0:GHC.Float
family instance modules: base-4.9.0.0:Control.Applicative
                         base-4.9.0.0:Data.Either base-4.9.0.0:Data.Functor.Const
                         base-4.9.0.0:Data.Monoid base-4.9.0.0:Data.Type.Equality
                         base-4.9.0.0:GHC.Generics base-4.9.0.0:GHC.IO.Exception
                         base-4.9.0.0:GHC.TypeLits
import  -/  base-4.9.0.0:Control.Monad 7767aebfd53f0b584cef2fe66ad3986c
import  -/  base-4.9.0.0:Data.Char eb33dc25ecb52d018a0ca26590e2b50b
import  -/  base-4.9.0.0:Data.Foldable 8aeb682f6c74f97fcf0ace0d608a43ea
import  -/  base-4.9.0.0:Data.List 49b86831b79b49ce5d4d9416ecba61df
import  -/  base-4.9.0.0:Data.Maybe 5f2ba364cbe65c060bc5436bc0b9d049
import  -/  base-4.9.0.0:Data.OldList 0058409f994fb13ae0616e3f1e5b4dae
import  -/  base-4.9.0.0:GHC.Base 8ed3be81c0707b322f975a84ae1bb816
import  -/  base-4.9.0.0:GHC.List 13d2451194c1c6e53b4f4f07947736dd
import  -/  base-4.9.0.0:GHC.Show 952347a6ab730bcb25c0854d8bc6ca51
import  -/  base-4.9.0.0:GHC.Unicode 2343b0871604cc5116abba8f24d75b42
import  -/  base-4.9.0.0:Prelude b9bddb97799837fe67a8d00939a5b6c3
import  -/  base-4.9.0.0:System.Exit 4df7be78e54bbe200276120bd44e7e2a
import  -/  base-4.9.0.0:System.IO ad985d7a3fc986e9b9c610fb344d9106
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  ghc-prim-0.5.0.0:GHC.Types 7378e41b7749213c8c88ceb6b0665d4c
dc5c78a909e854a27a2c0cecc217908c
  $fShowPuzzle :: GHC.Show.Show Puzzle.Puzzle
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Puzzle.Puzzle
                  Puzzle.$fShowPuzzle_$cshowsPrec
                  Puzzle.$fShowPuzzle_$cshow
                  Puzzle.$fShowPuzzle_$cshowList -}
dc5c78a909e854a27a2c0cecc217908c
  $fShowPuzzle1 ::
    Puzzle.Puzzle -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2, HasNoCafRefs,
     Unfolding: (\ (x :: Puzzle.Puzzle)
                   (s :: GHC.Base.String)[OneShot] ->
                 case x of ww { Puzzle.Puzzle ww1 ww2 ww3 ->
                 GHC.Base.++ @ GHC.Types.Char (Puzzle.$w$cshow ww2 ww3) s }) -}
393f331d2529a00c2bc3f54b3fc7334d
  $fShowPuzzle2 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# ' '#) -}
ac45506c0f1191569dd2fa7148b358d3
  $fShowPuzzle3 :: (GHC.Types.Char -> b -> b) -> b -> b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(C1(U))><L,U>,
     Unfolding: (\ @ b
                   (c :: GHC.Types.Char -> b -> b)[OneShot]
                   (n :: b)[OneShot] ->
                 GHC.CString.unpackFoldrCString#
                   @ b
                   " \n\
                   \\n\
                   \Guessed so far: "#
                   c
                   n) -}
dc5c78a909e854a27a2c0cecc217908c
  $fShowPuzzle_$cshow :: Puzzle.Puzzle -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSL),1*U(A,1*U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Puzzle.Puzzle) ->
                 case w of ww { Puzzle.Puzzle ww1 ww2 ww3 ->
                 Puzzle.$w$cshow ww2 ww3 }) -}
dc5c78a909e854a27a2c0cecc217908c
  $fShowPuzzle_$cshowList :: [Puzzle.Puzzle] -> GHC.Show.ShowS
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: (\ (ls :: [Puzzle.Puzzle]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__ @ Puzzle.Puzzle Puzzle.$fShowPuzzle1 ls s) -}
dc5c78a909e854a27a2c0cecc217908c
  $fShowPuzzle_$cshowsPrec ::
    GHC.Types.Int -> Puzzle.Puzzle -> GHC.Show.ShowS
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,A><S(LSL),1*U(A,1*U,U)><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Types.Int)
                   (x :: Puzzle.Puzzle)
                   (s :: GHC.Base.String) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (Puzzle.$fShowPuzzle_$cshow x))
                   s) -}
7dd9b070ba0b789f01638f8aef18b368
  $tc'Puzzle :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8888957307026398449##
                   12234156657364868822##
                   Puzzle.$trModule
                   Puzzle.$tc'Puzzle1) -}
99a39c489227ff5e617b568aa900ec7b
  $tc'Puzzle1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Puzzle"#) -}
9909c1b32e434f7772cbf0a71b65da93
  $tcPuzzle :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7985926324028929397##
                   12192401706805518782##
                   Puzzle.$trModule
                   Puzzle.$trModule1) -}
ce6265c28d06a0268bd9f65a55aa9850
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Puzzle.$trModule2
                   Puzzle.$trModule1) -}
c85cb6b6ca4151d8e1ec79c7fde690a1
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Puzzle"#) -}
09fba386b0ed4f84bca90027b81f8d0b
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "main"#) -}
2e6dbd76ef8a37fa5aa66859a608bfcd
  $w$cshow ::
    [GHC.Base.Maybe GHC.Types.Char]
    -> [GHC.Types.Char] -> GHC.Base.String
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: [GHC.Base.Maybe GHC.Types.Char])
                   (ww1 :: [GHC.Types.Char]) ->
                 case GHC.Base.map
                        @ (GHC.Base.Maybe GHC.Types.Char)
                        @ GHC.Types.Char
                        Puzzle.renderPuzzleChar
                        ww of wild {
                   []
                   -> Puzzle.$fShowPuzzle3
                        @ [GHC.Types.Char]
                        (GHC.Types.: @ GHC.Types.Char)
                        ww1
                   : x xs
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        (GHC.Types.:
                           @ GHC.Types.Char
                           x
                           (Data.OldList.prependToAll
                              @ GHC.Types.Char
                              Puzzle.$fShowPuzzle2
                              xs))
                        (Puzzle.$fShowPuzzle3
                           @ [GHC.Types.Char]
                           (GHC.Types.: @ GHC.Types.Char)
                           ww1) }) -}
6f060f30696f98e4951a359b7aaf61de
  $wgameOver ::
    GHC.Base.String
    -> [GHC.Types.Char]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 3, Strictness: <L,U><S,1*U><S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Base.String)
                   (ww1 :: [GHC.Types.Char])
                   (w :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case GHC.List.$wlenAcc @ GHC.Types.Char ww1 0# of ww2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># ww2 7#) of wild {
                   GHC.Types.False -> (# w, GHC.Tuple.() #)
                   GHC.Types.True
                   -> case GHC.IO.Handle.Text.hPutStr2
                             GHC.IO.Handle.FD.stdout
                             Puzzle.gameOver2
                             GHC.Types.True
                             w of ds1 { (#,#) ipv ipv1 ->
                      case GHC.IO.Handle.Text.hPutStr2
                             GHC.IO.Handle.FD.stdout
                             (GHC.CString.unpackAppendCString# "The word was: "# ww)
                             GHC.Types.True
                             ipv of ds2 { (#,#) ipv2 ipv3 ->
                      System.Exit.exitSuccess1 @ () ipv2 } } } }) -}
dc83b7eb0e9b90ee5c9a37773d1678c4
  $wgameWin ::
    [GHC.Base.Maybe GHC.Types.Char]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <S,1*U><S,U>, Inline: [0],
     Unfolding: (\ (ww :: [GHC.Base.Maybe GHC.Types.Char])
                   (w :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case (Puzzle.gameWin_go ww) `cast` (Data.Monoid.N:All[0]) of wild {
                   GHC.Types.False -> (# w, GHC.Tuple.() #)
                   GHC.Types.True
                   -> case GHC.IO.Handle.Text.hPutStr2
                             GHC.IO.Handle.FD.stdout
                             Puzzle.gameWin2
                             GHC.Types.True
                             w of ds1 { (#,#) ipv ipv1 ->
                      System.Exit.exitSuccess1 @ () ipv } }) -}
a42648fb7eb2500604cde8ee44b0b7a4
  $wrunGame ::
    GHC.Base.String
    -> [GHC.Base.Maybe GHC.Types.Char]
    -> [GHC.Types.Char]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 4, Strictness: <L,U><L,U><S,U><S,U>, Inline: [0] -}
dc5c78a909e854a27a2c0cecc217908c
  data Puzzle
    = Puzzle GHC.Base.String
             [GHC.Base.Maybe GHC.Types.Char]
             [GHC.Types.Char]
7842d5e865903535a8a9e83259ad0d28
  alreadyGuessed :: Puzzle.Puzzle -> GHC.Types.Char -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S(LLS),1*U(A,A,1*U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Puzzle.Puzzle) (guess :: GHC.Types.Char) ->
                 case ds of wild { Puzzle.Puzzle ds1 ds2 list ->
                 GHC.List.elem
                   @ GHC.Types.Char
                   GHC.Classes.$fEqChar
                   guess
                   list }) -}
3d9ff234310103203d4cf606c4500f65
  charInWord :: Puzzle.Puzzle -> GHC.Types.Char -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U,A,A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Puzzle.Puzzle) (guess :: GHC.Types.Char) ->
                 case ds of wild { Puzzle.Puzzle word ds1 ds2 ->
                 GHC.List.elem
                   @ GHC.Types.Char
                   GHC.Classes.$fEqChar
                   guess
                   word }) -}
ce4142065f504a8537973f24fcfcf317
  fillInCharacter :: Puzzle.Puzzle -> GHC.Types.Char -> Puzzle.Puzzle
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U,1*U,U)><L,U(U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Puzzle.Puzzle) (w1 :: GHC.Types.Char) ->
                 case w of ww { Puzzle.Puzzle ww1 ww2 ww3 ->
                 Puzzle.Puzzle
                   ww1
                   (GHC.List.zipWith
                      @ GHC.Types.Char
                      @ (GHC.Base.Maybe GHC.Types.Char)
                      @ (GHC.Base.Maybe GHC.Types.Char)
                      (\ (wordChar :: GHC.Types.Char)
                         (guessChar :: GHC.Base.Maybe GHC.Types.Char)[OneShot] ->
                       case wordChar of wild { GHC.Types.C# x ->
                       case w1 of wild1 { GHC.Types.C# y ->
                       case GHC.Prim.tagToEnum#
                              @ GHC.Types.Bool
                              (GHC.Prim.eqChar# x y) of wild2 {
                         GHC.Types.False -> guessChar
                         GHC.Types.True -> GHC.Base.Just @ GHC.Types.Char wild } } })
                      ww1
                      ww2)
                   (GHC.Types.: @ GHC.Types.Char w1 ww3) }) -}
5699b669c59339d983f0f24c8280ad8c
  freshPuzzle :: GHC.Base.String -> Puzzle.Puzzle
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (word :: GHC.Base.String) ->
                 Puzzle.Puzzle
                   word
                   (GHC.Base.build
                      @ (GHC.Base.Maybe GHC.Types.Char)
                      (\ @ b1
                         (c :: GHC.Base.Maybe GHC.Types.Char -> b1 -> b1)[OneShot]
                         (n :: b1)[OneShot] ->
                       GHC.Base.foldr
                         @ GHC.Types.Char
                         @ b1
                         (GHC.Base.mapFB
                            @ (GHC.Base.Maybe GHC.Types.Char)
                            @ b1
                            @ GHC.Types.Char
                            c
                            Puzzle.freshPuzzle1)
                         n
                         word))
                   (GHC.Types.[] @ GHC.Types.Char)) -}
2fcab90b5c3a58de6ae86452c4f9e384
  freshPuzzle1 :: GHC.Types.Char -> GHC.Base.Maybe GHC.Types.Char
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: GHC.Types.Char) -> GHC.Base.Nothing @ GHC.Types.Char) -}
c82859d600196e669a5dd46a6c61f616
  gameOver :: Puzzle.Puzzle -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <S(LLS),1*U(U,A,1*U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Puzzle.gameOver1
                  `cast`
                (<Puzzle.Puzzle>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
8db8903390739f5564dbdff3491dbca3
  gameOver1 ::
    Puzzle.Puzzle
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <S(LLS),1*U(U,A,1*U)><S,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Puzzle.Puzzle)
                   (w1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case w of ww { Puzzle.Puzzle ww1 ww2 ww3 ->
                 Puzzle.$wgameOver ww1 ww3 w1 }) -}
d7dbcf283dd5ab7eb285bb4398979ed7
  gameOver2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "You lose!"#) -}
07238b094ea9e424d7187b3f37d88d9b
  gameWin :: Puzzle.Puzzle -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <S(LSL),1*U(A,1*U,A)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Puzzle.gameWin1
                  `cast`
                (<Puzzle.Puzzle>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
0d6451fabd743ab953d6a0024907d566
  gameWin1 ::
    Puzzle.Puzzle
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <S(LSL),1*U(A,1*U,A)><S,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Puzzle.Puzzle)
                   (w1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case w of ww { Puzzle.Puzzle ww1 ww2 ww3 ->
                 Puzzle.$wgameWin ww2 w1 }) -}
6c4859ab2e1c6ee9432397b6b3964fc9
  gameWin2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "You win!"#) -}
56291d556aac28659f5f9308c2313308
  gameWin_go :: [GHC.Base.Maybe GHC.Types.Char] -> Data.Monoid.All
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
a6bfcfeab272ab6ce803dbc54ecbc770
  handleGuess ::
    Puzzle.Puzzle -> GHC.Types.Char -> GHC.Types.IO Puzzle.Puzzle
  {- Arity: 3, Strictness: <L,1*U(U,U,U)><L,U(U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Puzzle.handleGuess1
                  `cast`
                (<Puzzle.Puzzle>_R
                 ->_R <GHC.Types.Char>_R
                 ->_R Sym (GHC.Types.N:IO[0] <Puzzle.Puzzle>_R)) -}
0fb3f9d8f261d9eb345f2585773302c5
  handleGuess1 ::
    Puzzle.Puzzle
    -> GHC.Types.Char
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Puzzle.Puzzle #)
  {- Arity: 3, Strictness: <L,1*U(U,U,U)><L,U(U)><S,U>,
     Unfolding: (\ (puzzle :: Puzzle.Puzzle)
                   (guess :: GHC.Types.Char)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case GHC.IO.Handle.Text.hPutStr2
                        GHC.IO.Handle.FD.stdout
                        (GHC.CString.unpackAppendCString#
                           "Your guess was: "#
                           (GHC.Types.:
                              @ GHC.Types.Char
                              guess
                              (GHC.Types.[] @ GHC.Types.Char)))
                        GHC.Types.True
                        s of ds1 { (#,#) ipv ipv1 ->
                 case puzzle of wild { Puzzle.Puzzle ds ds2 list ->
                 case GHC.List.elem
                        @ GHC.Types.Char
                        GHC.Classes.$fEqChar
                        guess
                        list of wild1 {
                   GHC.Types.False
                   -> case GHC.List.elem
                             @ GHC.Types.Char
                             GHC.Classes.$fEqChar
                             guess
                             ds of wild2 {
                        GHC.Types.False
                        -> case GHC.IO.Handle.Text.hPutStr2
                                  GHC.IO.Handle.FD.stdout
                                  Puzzle.handleGuess4
                                  GHC.Types.True
                                  ipv of ds3 { (#,#) ipv2 ipv3 ->
                           (# ipv2,
                              Puzzle.Puzzle
                                ds
                                (GHC.List.zipWith
                                   @ GHC.Types.Char
                                   @ (GHC.Base.Maybe GHC.Types.Char)
                                   @ (GHC.Base.Maybe GHC.Types.Char)
                                   (\ (wordChar :: GHC.Types.Char)
                                      (guessChar :: GHC.Base.Maybe GHC.Types.Char)[OneShot] ->
                                    case wordChar of wild3 { GHC.Types.C# x ->
                                    case guess of wild4 { GHC.Types.C# y ->
                                    case GHC.Prim.tagToEnum#
                                           @ GHC.Types.Bool
                                           (GHC.Prim.eqChar# x y) of wild5 {
                                      GHC.Types.False -> guessChar
                                      GHC.Types.True -> GHC.Base.Just @ GHC.Types.Char wild3 } } })
                                   ds
                                   ds2)
                                (GHC.Types.: @ GHC.Types.Char guess list) #) }
                        GHC.Types.True
                        -> case GHC.IO.Handle.Text.hPutStr2
                                  GHC.IO.Handle.FD.stdout
                                  Puzzle.handleGuess3
                                  GHC.Types.True
                                  ipv of ds3 { (#,#) ipv2 ipv3 ->
                           (# ipv2,
                              Puzzle.Puzzle
                                ds
                                (GHC.List.zipWith
                                   @ GHC.Types.Char
                                   @ (GHC.Base.Maybe GHC.Types.Char)
                                   @ (GHC.Base.Maybe GHC.Types.Char)
                                   (\ (wordChar :: GHC.Types.Char)
                                      (guessChar :: GHC.Base.Maybe GHC.Types.Char)[OneShot] ->
                                    case wordChar of wild3 { GHC.Types.C# x ->
                                    case guess of wild4 { GHC.Types.C# y ->
                                    case GHC.Prim.tagToEnum#
                                           @ GHC.Types.Bool
                                           (GHC.Prim.eqChar# x y) of wild5 {
                                      GHC.Types.False -> guessChar
                                      GHC.Types.True -> GHC.Base.Just @ GHC.Types.Char wild3 } } })
                                   ds
                                   ds2)
                                (GHC.Types.: @ GHC.Types.Char guess list) #) } }
                   GHC.Types.True
                   -> case GHC.IO.Handle.Text.hPutStr2
                             GHC.IO.Handle.FD.stdout
                             Puzzle.handleGuess2
                             GHC.Types.True
                             ipv of ds3 { (#,#) ipv2 ipv3 ->
                      (# ipv2, wild #) } } } }) -}
3da64826f0c472a7a11543a447246673
  handleGuess2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "You already guessed that character, pick something else!"#) -}
b1eb8d819dbef8189f7b0ff0b681ff5e
  handleGuess3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "This character was in the word, filling in the word accordingly"#) -}
8672143d50e819d9c3f8cea3378c4cd5
  handleGuess4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "This character wasn't in the word, try again."#) -}
8de8c9c069b94ca26982371bf72b93ca
  renderPuzzleChar :: GHC.Base.Maybe GHC.Types.Char -> GHC.Types.Char
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: GHC.Base.Maybe GHC.Types.Char) ->
                 case ds of wild {
                   GHC.Base.Nothing -> Puzzle.renderPuzzleChar1
                   GHC.Base.Just a -> a }) -}
45049981f4b8f6e4dc61fda7f912bce0
  renderPuzzleChar1 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# '_'#) -}
114f9aab82965e64bd46de3a7dcc684b
  runGame :: Puzzle.Puzzle -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <S(LLS),U(U,U,U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Puzzle.runGame1
                  `cast`
                (<Puzzle.Puzzle>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
1e771f52dce3ce6716d54c437e541d56
  runGame1 ::
    Puzzle.Puzzle
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <S(LLS),U(U,U,U)><S,U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Puzzle.Puzzle)
                   (w1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case w of ww { Puzzle.Puzzle ww1 ww2 ww3 ->
                 Puzzle.$wrunGame ww1 ww2 ww3 w1 }) -}
instance [safe] GHC.Show.Show [Puzzle.Puzzle] = Puzzle.$fShowPuzzle
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

