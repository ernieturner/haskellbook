
==================== FINAL INTERFACE ====================
2017-02-01 18:25:23.948053 UTC

interface hangman-0.1.0.0-CcXPL4z5XJ16AKbxhRZoP9:PuzzleType 8001
  interface hash: f28ba68d8ad26782b6ffcc909074d2a7
  ABI hash: 2d9e47da185ac721af5968bdf65b9729
  export-list hash: 8d332e19d44b14a8f1fe84e1146b4e7f
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: a4046e0fdab24403354cf30558c1ea1c
  sig of: Nothing
  used TH splices: False
  where
exports:
  PuzzleType.renderPuzzleChar
  PuzzleType.Puzzle{PuzzleType.Puzzle}
module dependencies:
package dependencies: base-4.9.0.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.0.0:GHC.Base base-4.9.0.0:GHC.Float
family instance modules: base-4.9.0.0:Control.Applicative
                         base-4.9.0.0:Data.Either base-4.9.0.0:Data.Functor.Const
                         base-4.9.0.0:Data.Monoid base-4.9.0.0:Data.Type.Equality
                         base-4.9.0.0:GHC.Generics base-4.9.0.0:GHC.IO.Exception
                         base-4.9.0.0:GHC.TypeLits
import  -/  base-4.9.0.0:Data.List 49b86831b79b49ce5d4d9416ecba61df
import  -/  base-4.9.0.0:Data.OldList 0058409f994fb13ae0616e3f1e5b4dae
import  -/  base-4.9.0.0:GHC.Base 8ed3be81c0707b322f975a84ae1bb816
import  -/  base-4.9.0.0:GHC.Show 952347a6ab730bcb25c0854d8bc6ca51
import  -/  base-4.9.0.0:Prelude b9bddb97799837fe67a8d00939a5b6c3
c1dd6480eb3e4c8cffcbdb80d6bf144f
  $fShowPuzzle :: GHC.Show.Show PuzzleType.Puzzle
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PuzzleType.Puzzle
                  PuzzleType.$fShowPuzzle_$cshowsPrec
                  PuzzleType.$fShowPuzzle_$cshow
                  PuzzleType.$fShowPuzzle_$cshowList -}
c1dd6480eb3e4c8cffcbdb80d6bf144f
  $fShowPuzzle1 ::
    PuzzleType.Puzzle -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2, HasNoCafRefs,
     Unfolding: (\ (x :: PuzzleType.Puzzle)
                   (s :: GHC.Base.String)[OneShot] ->
                 case x of ww { PuzzleType.Puzzle ww1 ww2 ww3 ->
                 GHC.Base.++ @ GHC.Types.Char (PuzzleType.$w$cshow ww2 ww3) s }) -}
6d7c732672fb7bda28fc092675953f47
  $fShowPuzzle2 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# ' '#) -}
8ed5407bd37f7e9f511e973f491fb4c1
  $fShowPuzzle3 :: (GHC.Types.Char -> b -> b) -> b -> b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(C1(U))><L,U>,
     Unfolding: (\ @ b
                   (c :: GHC.Types.Char -> b -> b)[OneShot]
                   (n :: b)[OneShot] ->
                 GHC.CString.unpackFoldrCString#
                   @ b
                   " \n\
                   \\n\
                   \Guessed so far: "#
                   c
                   n) -}
c1dd6480eb3e4c8cffcbdb80d6bf144f
  $fShowPuzzle_$cshow :: PuzzleType.Puzzle -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSL),1*U(A,1*U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: PuzzleType.Puzzle) ->
                 case w of ww { PuzzleType.Puzzle ww1 ww2 ww3 ->
                 PuzzleType.$w$cshow ww2 ww3 }) -}
c1dd6480eb3e4c8cffcbdb80d6bf144f
  $fShowPuzzle_$cshowList :: [PuzzleType.Puzzle] -> GHC.Show.ShowS
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: (\ (ls :: [PuzzleType.Puzzle]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ PuzzleType.Puzzle
                   PuzzleType.$fShowPuzzle1
                   ls
                   s) -}
c1dd6480eb3e4c8cffcbdb80d6bf144f
  $fShowPuzzle_$cshowsPrec ::
    GHC.Types.Int -> PuzzleType.Puzzle -> GHC.Show.ShowS
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,A><S(LSL),1*U(A,1*U,U)><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Types.Int)
                   (x :: PuzzleType.Puzzle)
                   (s :: GHC.Base.String) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (PuzzleType.$fShowPuzzle_$cshow x))
                   s) -}
30accf2be63725c3c7079ee64dead709
  $tc'Puzzle :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14370902398864849887##
                   10359942182081844275##
                   PuzzleType.$trModule
                   PuzzleType.$tc'Puzzle1) -}
61e18e7681248b106dd3e7c3327a654e
  $tc'Puzzle1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Puzzle"#) -}
0c580d0ef671fd8088eae0ed410cb10d
  $tcPuzzle :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7219279932176868779##
                   8506310152065340862##
                   PuzzleType.$trModule
                   PuzzleType.$tcPuzzle1) -}
6e7786972f0876d56593eb6d0bddddeb
  $tcPuzzle1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Puzzle"#) -}
a6305adffe7137c1703e8030e38f1198
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   PuzzleType.$trModule2
                   PuzzleType.$trModule1) -}
41847097258a5a6119e4e7de9aad82d2
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "PuzzleType"#) -}
9d032325f0e6993a8ba59a70a8dfbf44
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "hangman-0.1.0.0-CcXPL4z5XJ16AKbxhRZoP9"#) -}
549e11c5cc3eda0cfca6eae780c6f735
  $w$cshow ::
    [GHC.Base.Maybe GHC.Types.Char]
    -> [GHC.Types.Char] -> GHC.Base.String
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: [GHC.Base.Maybe GHC.Types.Char])
                   (ww1 :: [GHC.Types.Char]) ->
                 case GHC.Base.map
                        @ (GHC.Base.Maybe GHC.Types.Char)
                        @ GHC.Types.Char
                        PuzzleType.renderPuzzleChar
                        ww of wild {
                   []
                   -> PuzzleType.$fShowPuzzle3
                        @ [GHC.Types.Char]
                        (GHC.Types.: @ GHC.Types.Char)
                        ww1
                   : x xs
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        (GHC.Types.:
                           @ GHC.Types.Char
                           x
                           (Data.OldList.prependToAll
                              @ GHC.Types.Char
                              PuzzleType.$fShowPuzzle2
                              xs))
                        (PuzzleType.$fShowPuzzle3
                           @ [GHC.Types.Char]
                           (GHC.Types.: @ GHC.Types.Char)
                           ww1) }) -}
c1dd6480eb3e4c8cffcbdb80d6bf144f
  data Puzzle
    = Puzzle GHC.Base.String
             [GHC.Base.Maybe GHC.Types.Char]
             [GHC.Types.Char]
d7e51511b21fe737ada80aaf6bc81958
  renderPuzzleChar :: GHC.Base.Maybe GHC.Types.Char -> GHC.Types.Char
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: GHC.Base.Maybe GHC.Types.Char) ->
                 case ds of wild {
                   GHC.Base.Nothing -> PuzzleType.renderPuzzleChar1
                   GHC.Base.Just a -> a }) -}
d9dea425106ebf45d259cd8153187692
  renderPuzzleChar1 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# '_'#) -}
instance [safe] GHC.Show.Show [PuzzleType.Puzzle]
  = PuzzleType.$fShowPuzzle
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

